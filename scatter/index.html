<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Scatter plot with voronoi and zoom</title>
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,300,600|Open+Sans+Condensed:300' rel='stylesheet' type='text/css'>
  <meta name="description" content="Plot data in a scatter plot with Voronoi detection to find the nearest point">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no" />
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../lib/globalStyle.css" />
  <link href='../lib/global.css' rel='stylesheet'/>


  <style>

/**Zoe changes*/

        body {
          font-family: "Open Sans", sans-serif;
          font-size: 14px;
          max-width: 950px;
          cursor: pointer !important;

        }

        .axis path,
        .axis line {
          fill: none;
          stroke: #000;
          shape-rendering: crispEdges;
        }

        .y.axis path {
          display: none;
        }

        .overlay1 {
            fill: none;
            stroke: none;
            pointer-events: all;

        }

        .focusLine {
            fill: none;
            stroke: steelblue;
            stroke-width: 0.5px;
        }

        .focusCircle {
            fill: #FFA500;
            stroke: #212121;
            stroke-width: 3px;
        }

        .highlightedCircle {
            fill: orange;
            stroke: orange;
            stroke-width: 2px;
        }


        .focusUK {
            fill: #000;
        }

        .hull {
          opacity:0.2;
          stroke-linejoin: round;
          stroke-width:20px;


        .annotation-note-bg {
          fill: fuchsia !important;
          fill-opacity: 0.5 !important;
        }


    </style>
</head>
<body>
<div class="select">
  <select id="varselect"></select>
</div>
<div id="graphic"><img src="fallback.png" alt="[Chart]" /></div>


<div class="footer"> <div id="footer"></div></div>
</body>
  <script src="https://d3js.org/d3.v4.min.js" type="text/javascript"></script>
  <script src="../lib/d3-annotation.js" type="text/javascript"></script>
  <script src="../lib/modernizr.svg.min.js" type="text/javascript"></script>
  <script src="../lib/jquery.js" type="text/javascript"></script>
  <script src="../lib/bootstrap.min.js" type="text/javascript"></script>
  <script src="../lib/pym.js" charset="utf-8" type="text/javascript"></script>
  <!-- <script src="../lib/saveSvgAsPng.js" type="text/javascript"></script>
  <script src="../lib/footer.js" type="text/javascript"></script> -->
  <script>

var pymChild = null;
var graphic = d3.select('#graphic');
var footer = d3.select("#footer");
var dvc = {};
var xpos;
var ypos;
var makeAnnotations;


function drawGraphic(){

  // initialise breakpoint for medium and small screens
  var threshold_md = 788;
  var threshold_sm = dvc.optional.mobileBreakpoint;

  //set variables for chart dimensions dependent on width of #graphic
  if (parseInt(graphic.style("width"))  < threshold_sm) {
      // set mobile size margins, height and width
      var margin = {top: dvc.optional.margin_sm[0], right: dvc.optional.margin_sm[1], bottom: dvc.optional.margin_sm[2], left: dvc.optional.margin_sm[3]};
      var chart_width = parseInt(graphic.style("width") ) - margin.left - margin.right;
      var height = Math.ceil((chart_width * dvc.optional.aspectRatio_sm[1]) / dvc.optional.aspectRatio_sm[0]);
  } else if (parseInt(graphic.style("width"))  < threshold_md) {
      // set medium size margins, height and width
      var margin = {top: dvc.optional.margin_md[0], right: dvc.optional.margin_md[1], bottom: dvc.optional.margin_md[2], left: dvc.optional.margin_md[3]};
      var chart_width = parseInt(graphic.style("width") ) - margin.left - margin.right;
      var height = Math.ceil((chart_width * dvc.optional.aspectRatio_md[1]) / dvc.optional.aspectRatio_md[0]);
  } else {
      // set large size margins, height and width
      var margin = {top: dvc.optional.margin_lg[0], right: dvc.optional.margin_lg[1], bottom: dvc.optional.margin_lg[2], left: dvc.optional.margin_lg[3]}
      var chart_width = parseInt(graphic.style("width") ) - margin.left - margin.right;
      var height = Math.ceil((chart_width * dvc.optional.aspectRatio_lg[1]) / dvc.optional.aspectRatio_lg[0]);

  } // end else ...

  // clear out existing graphics
		graphic.selectAll("*").remove();
		footer.selectAll("*").remove();

  //draw select menu
  drawSelect();

  // parse data into columns
  dots = {};

  // for each 'column' in data object
  for (var column in graphic_data[0]) {
    // dots object with content from graphic_data
    dots[column] = graphic_data.map(function(d,i) {
      // return object variables to use in code. This needs to be updated in accordance with field content of files
      return {
        'group' : d.group,
        'name' : d.name,
        'size' : +d.in_employment,
        'SPD' : +d[dvc.essential.pickxdata],
        'Census' : +d[dvc.essential.pickydata]
      };

    });
  }

//reformat the data for the voronoi
  var makingdata = [];
  makingdata.push(makedata());
  function makedata(){
    var data=[];
    for(var i=0;i<graphic_data.length;i++)
    {
    data.push([graphic_data[i][dvc.essential.pickxdata],graphic_data[i][dvc.essential.pickydata]]);
    }
  return data;
}
      var svg = d3.select('#graphic').append('svg')
                  .attr('width', chart_width + margin.left + margin.right)
                  .attr('height', height + margin.top + margin.bottom +50);

      var g = svg.append('g')
        .attr('transform', 'translate(' + margin.left + ', ' + margin.top + ')')
        .attr('overflow', 'hidden');

      if(dvc.essential.AxisScale == "auto_min_max"){
      var minX = d3.min(d3.entries(dots), function(c) {
        									return d3.min(c.value, function(v) {
        										var n = v.SPD;
        										return Math.floor(n);
        									});
        								})
      var maxX = d3.max(d3.entries(dots), function(c) {
        									return d3.max(c.value, function(v) {
        										var n = v.SPD;
        										return Math.ceil(n);
        									});
        								});
      var minY = d3.min(d3.entries(dots), function(c) {
        									return d3.min(c.value, function(v) {
        										var n = v.Census;
        										return Math.floor(n);
        									});
        								})
      var maxY = d3.max(d3.entries(dots), function(c) {
        									return d3.max(c.value, function(v) {
        										var n = v.Census;
        										return Math.ceil(n);
        									});
        								})

      var minR = d3.min(d3.entries(dots), function(c) {
        									return d3.min(c.value, function(v) {
        										var n = v.size;
        										return Math.floor(n);
        									});
        								})
      var maxR = d3.max(d3.entries(dots), function(c) {
        									return d3.max(c.value, function(v) {
        										var n = v.size;
        										return Math.ceil(n);
        									});
        								})
      }else{
        var minX = dvc.essential.xAxisScale[0];
        var maxX = dvc.essential.xAxisScale[1];
        var minY = dvc.essential.yAxisScale[0];
        var maxY = dvc.essential.yAxisScale[1];
        var minR = d3.min(d3.entries(dots), function(c) {
                            return d3.min(c.value, function(v) {
                              var n = v.size;
                              return Math.floor(n);
                            });
                          })
        var maxR = d3.max(d3.entries(dots), function(c) {
                            return d3.max(c.value, function(v) {
                              var n = v.size;
                              return Math.ceil(n);
                            });
                          })
      }



      var ratio =  height / chart_width;

       x = d3.scaleLinear()
                     .range([0, chart_width])
                     .domain([minX, maxX]);

       y = d3.scaleLinear()
                     .range([height, 0])
                     .domain([minY, maxY]);

       r = d3.scaleLinear()
                     .range([0, 100])
                     .domain([minR, maxR]);


      var line = d3.line()
         .x(function(d) { return x(d[0]); })
         .y(function(d) { return y(d[1]); });


      var xAxis = d3.axisBottom(x),
          yAxis = d3.axisLeft(y);

    //specify number or ticks on y axis
  	if (parseInt(graphic.style("width") ) <= threshold_sm) {
  		yAxis.ticks(dvc.optional.y_num_ticks_sm_md_lg[0])
  	 } else if (parseInt(graphic.style("width") ) <= threshold_md){
  		yAxis.ticks(dvc.optional.y_num_ticks_sm_md_lg[1])
  	 } else {
  		yAxis.ticks(dvc.optional.y_num_ticks_sm_md_lg[2])
  	 }

     //specify number or ticks on y axis
    if (parseInt(graphic.style("width") ) <= threshold_sm) {
      xAxis.ticks(dvc.optional.x_num_ticks_sm_md_lg[0])
     } else if (parseInt(graphic.style("width") ) <= threshold_md){
      xAxis.ticks(dvc.optional.x_num_ticks_sm_md_lg[1])
     } else {
      xAxis.ticks(dvc.optional.x_num_ticks_sm_md_lg[2])
     }


      g.append('g')
         .attr('class', 'x-axis grid axis')
         .attr('transform', 'translate(0, ' + height + ')')
         .call(xAxis.tickSize(-height, 0, 0))
         .append('text')
           .attr('x', chart_width)
           .attr('dy', '2.5em')
           .attr('text-anchor', 'end')
           .attr('fill', 'rgb(54, 54, 54)')
           .attr('font-size', '1.2em')
           .text(function(d,i){return dvc.essential.xAxisLabel});

      g.append('g')
         .attr('class', 'y-axis grid axis')
         .call(yAxis.tickSize(-chart_width, 0, 0))
         .append('text')
             .attr('y', 10)
             .attr('dy', '-2em')
             .attr('dx','-3em')
             .attr('text-anchor', 'start')
             .attr('fill', 'rgb(54, 54, 54)')
             .attr('font-size', '1.2em')
             .text(function(d,i){return dvc.essential.yAxisLabel})

      g.append('defs')
         .append('clipPath')
         .attr('id', 'clip')
         .append('rect')
           .attr('x', 0)
           .attr('y', 0)
           .attr('width', chart_width)
           .attr('height', height);

      var hulls = g.append('g')
          .attr('class','hulls')

      var main = g.append('g')
         .attr('class', 'main')
         .attr('clip-path', 'url(#clip)');

         dvc.optional.annotateLineX1_Y1_X2_Y2.forEach(function(d,i) {
           main.append('path')
              .datum(dvc.optional.annotateLineX1_Y1_X2_Y2[i])
              .attr('d', line)
              .attr('stroke', dvc.optional.lineColor_opcty[i][0])
              .style('stroke-width', 1)
              .attr('stroke-opacity',dvc.optional.lineColor_opcty[i][1])
              .attr('fill', 'none')
              .attr('class', 'line');
            })

         main.selectAll('.circles').data(graphic_data).enter().append('circle')
            .attr( "class" , function(d,i){ return "circles " + d.group + " " + d["name"].replace(/\s/g, '') + " index" + i  })
            .attr( "id" , function (d,i){ return "c" + d.uk_2010_soc_code; })
            .attr( "cx" , function(d) { return x(d[dvc.essential.pickxdata]); })
    				.attr( "cy" , function(d) { return y(d[dvc.essential.pickydata]); })
            .attr('r', function(d) { return r(d.in_employment); })
          //  .attr('fill', function(d) { return y(d[dvc.essential.pickydata]); })
          //  .attr('stroke', "red")
            .attr("opacity", 0.6)
            .attr('stroke-width', 1)
          //  .attr('class', 'circles');


            vertices = [];
            hullVertices = []

          for(j=0; j<dvc.essential.fills.length; j++){
              d3.selectAll(".grp" + (j+1))
                .attr('fill', dvc.essential.fills[j])
                .attr('stroke',"#b4b4b4")
                .attr("stroke-width","1px")
          }
          // draw convex hulls
          // for(j=0; j<dvc.essential.fills.length; j++){
          //
          //
          //   vertices[j] = [];
          //
          //   filtered =graphic_data.filter(function(d){return d.group == 'grp' + (j+1);})
          //
          //   for(i=0; i<filtered.length; i++) {
          //     vertices[j].push([x(filtered[i][dvc.essential.pickxdata]),y(filtered[i][dvc.essential.pickydata])])
          //   }
          //
          //   hullVertices[j] = d3.polygonHull(vertices[j])
          //
          //   hulls.append("path")
          //     .attr("class","hull")
          //     .attr("fill",dvc.essential.fills[j])
          //     .attr("stroke",dvc.essential.fills[j])
          //     .datum(hullVertices[j])
          //     .attr("d", function(d) { return "M" + d.join("L") + "Z"; });
          // }



          //create link to source
          d3.select('#footer').append("p")
                .attr("id", "source")
                .text("Source: ")
                .append("a")
                .style("fill", "#4774CC")  // it ignored the css !!
                .attr("href", dvc.essential.sourceURL)
                .attr("target", "_blank")
                .text(dvc.essential.sourceText);

          // make rectangle annotations
          dvc.essential.rectannotations.forEach(function(d,i) {
                   main.append('rect')
                    .datum(dvc.essential.rectannotations[i])
                    .attr("x",x(d.x))
                    .attr("y",y(d.y))
                    .attr("width",Math.abs(x(dvc.essential.rectannotations[i].width)-x(0)))
                    .attr("height",Math.abs(y(dvc.essential.rectannotations[i].height)-y(0)))
                    .attr('class','rect')
                    .attr("fill",d.colour)
                    .attr("opacity",d.opacity);
                  })

          // make written annotations
          dvc.essential.textAnnotations.forEach(function(d,i) {
                   main.append('text')
                    .datum(dvc.essential.textAnnotations[i])
                    .attr("x",x(d.x))
                    .attr("y",y(d.y))
                    .attr("class","annotext")
                    .text(d.text)
                    .call(wrap,dvc.essential.textAnnotationWrap);

                      console.log(d)
                    d3.selectAll("#c" + d.soc).classed("highlightedCircle",true).raise();


                  })

//d3-annotations tooltips(from https://bl.ocks.org/Fil/17fc857c3ce36bf8e21ddefab8bc9af4/167bce6e2b706016004a3baf14f838203646a27a)

      // create a container for tooltips
      tipg = svg.append("g")
        .attr("class", "annotation-tip");


      // this function will call d3.annotation when a tooltip has to be drawn
        function tip (d) {

          annotationtip = d3.annotation()
          .type(d3.annotationLabel)
          .notePadding(30)
          .annotations([d].map( d =>  {
            return {
              data: {x:d.data[0],y:d.data[1]},
              className: "show-bg",
              dx: (d[0] > chart_width/2) ? -30 : 30,
              dy: (d[1] > height/2) ? -30 : 30,

              note: {
                 align: "middle",
                 title: graphic_data[d.index].name || "??",
                 bgPadding: {top:35, left:15, bottom:15, right:15},
                 label: "Exposure to disease"+": "+d3.format('.1f')(d.data[1])+" "+ ",Physical proximity" +": "+d3.format('.1f')(d.data[0]),
                 wrapSplitter: /,/,
                 wrap:dvc.essential.d3AnnotationWrap
              }//,
              // subject: {
              //   radius: 4,
              //   radiusPadding: 0,
              // },

            };
          }))
          .accessors({ x: d => x(d.x)+margin.left, y: d => y(d.y)+margin.top})

          tipg.call(annotationtip);


          d3.select("rect.annotation-note-bg").attr("fill","#fff").attr("fill-opacity",1).attr("opacity",1)//.attr("rx",5).attr("ry",5).attr("stroke","#fff").attr("stroke-width","10px");
          d3.select(".annotation-note-label").attr("fill","#236092");
          d3.select(".annotation-note-title").attr("fill","#236092").style("font-weight","bold").style("font-family","Open Sans");

          d3.select("#annotation-close").remove();

          xclose = d3.select("rect.annotation-note-bg").attr("width");

          d3.select(".annotation-note-content")
            .append("svg:image")
            .attr('x', xclose - 40)
            .attr('y', -27)
            .attr('width', 16)
            .attr('height', 16)
            .attr("id","annotation-close")
            .attr("xlink:href", "../lib/closeblue.svg")
            .on("click",function() {
                tipg.selectAll("g").remove();
                d3.selectAll(".circles").classed("focusCircle",false);
                d3.select(".overlay1").style("pointer-events","all");
            })


          d3.select(".connector").attr("stroke","#236092")
        } //end tip()

      //voronoi

      var vorData = d3.merge(makingdata);

      var voronoi = d3.voronoi()
          .x(function(d) {return x(d[0]); })
          .y(function(d) {return y(d[1]); })
          .size([chart_width, height])(vorData);

      var voronoiRadius = chart_width;


      //focus
      // var focus = g.append('g').style('display', 'none');
      //
      // focus.append('line')
      //     .attr('id', 'focusLineX')
      //     .attr('class', 'focusLine');
      // focus.append('line')
      //     .attr('id', 'focusLineY')
      //     .attr('class', 'focusLine');
      // focus.append('circle')
      //     .attr('id', 'focusCircle')
      //     .attr('r', 4)
      //     .attr('class', 'circle focusCircle');

      if ( parseInt(graphic.style("width")) > dvc.optional.mobileBreakpoint ) {

      svg.append('rect').attr("class","overlay1")
          .attr('transform', 'translate(' + margin.left + ', ' + margin.top + ')')
          .attr('width', chart_width)
          .attr('height', height)
          //.on('mouseover', function() { focus.style('display', null); })
          .on('mouseout', function() {tipg.selectAll("g").remove(); d3.selectAll(".circles").classed("focusCircle",false); })
          .on('mousemove', hover)

          function hover() {

              var [mx, my] = d3.mouse(this);


              // use the new diagram.find() function to find the Voronoi site
              // closest to the mouse, limited by max distance voronoiRadius
              var site = voronoi.find(mx, my, voronoiRadius);

              //console.log(splited = str.split(" ");)

              classString = d3.select(".index" + site.index).attr("class");

              splitString = classString.split(" ");
              d3.selectAll(".circles").classed("focusCircle",false);
              d3.selectAll("." + splitString[2]).classed("focusCircle",true).raise();
              code = d3.select(".index" + site.index).attr("id")
              console.log(code)
              $("#varselect").val(code);


              tip(site);//tooltip stuff
              var xpos = site[0];
              var ypos = site[1];

              // focus.select('#focusCircle')
              //     .attr('cx', xpos)
              //     .attr('cy', ypos);
              // focus.select('#focusLineX')
              //     .attr('x1', xpos).attr('y1', y(y.domain()[0]))
              //     .attr('x2', xpos).attr('y2', ypos);
              // focus.select('#focusLineY')
              //     .attr('x1', x(x.domain()[0])).attr('y1', ypos)
              //     .attr('x2', xpos).attr('y2', ypos);


          }

}//end if wider than mobileBreakpoint then do stuff


      //word wrapping function from https://stackoverflow.com/questions/24784302/wrapping-text-in-d3
      function wrap(text, width) {
        text.each(function() {
          var text = d3.select(this),
              words = text.text().split(/\s+/).reverse(),
              word,
              line = [],
              lineNumber = 0,
              lineHeight = 1.1, // ems
              x = text.attr("x"),
              y = text.attr("y"),
              dy = 0,//parseFloat(text.attr("dy")),
              tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");
          while (word = words.pop()) {
            line.push(word);
            tspan.text(line.join(" "));
            if (tspan.node().getComputedTextLength() > width) {
              line.pop();
              tspan.text(line.join(" "));
              line = [word];
              tspan = text.append("tspan").attr("x", x).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
            }
          }
        });
      }



      function drawSelect() {

        count=0;

        hierarchy = d3.map(graphic_data, function(d){return d.grouphier;}).keys();

        labels = graphic_data.map(function(d) { return d.name; });

        hier = graphic_data.map(function(d) { return d.grouphier; });

        codes = graphic_data.map(function(d) { return "c" + d.uk_2010_soc_code; });

        mergedvars = d3.zip(hier,labels,codes)

        console.log(hierarchy)

        hierarchy.forEach(function(k,j) {


          optgroup = d3.select("#varselect")
            //.attr("name","select")
            .on("change",selectCircle)
            .append("optgroup")
            .attr("label",k)

          optgroup.selectAll('option')
              .data(mergedvars.filter(function(d,i){return d[0] == hierarchy[j]}))
              .enter()
              .append("option")
              .attr("value", function(d,i){return d[2]})
              .text(function(d,i) {
                var value = parseFloat(d[1]).toFixed(1);
                return d[1];
              })


          count = count + mergedvars.filter(function(d,i){return d[0] == hierarchy[j]}).length;

      });

      function selectCircle() {

        console.log("selectCircle")

        selocc = d3.select("#varselect").node().value;
        window.location.hash = selocc;


        //layername = d3.select(this).node().value;
        d3.select(".overlay1").style("pointer-events","none");

        d3.selectAll(".circles").classed("focusCircle",false);
        d3.selectAll("#" + selocc).classed("focusCircle",true).raise();

        xpos = d3.selectAll("#" + selocc).attr("cx");
        ypos = d3.selectAll("#" + selocc).attr("cy");

        classString = d3.select("#" + selocc).attr("class");

        splitString = classString.split(" ");

        console.log(splitString)

        indexString = splitString[3].split("index");

        myObj = {}

        myObj[0] = xpos;
        myObj[1] = ypos;

        xVal = x.invert(xpos);
        yVal =y.invert(ypos);
        myObj['data'] = [xVal,yVal];
        myObj['index'] = indexString[1]

        console.log(myObj)
        tip(myObj)

      } //end selectCircle
    }//end drawSelect
    function checkUrl() {

     urlLocal = window.location.href;

     var listnamesLocal = urlLocal.split("#")[1];
    console.log(urlLocal)
     if(listnamesLocal != undefined) {

       listnamesA = listnamesLocal.split(',').slice(0).join(',');

       listnames = 	listnamesA.split(',');

        d3.selectAll(".circles").classed("focusCircle",false);
        d3.selectAll("#" + listnames).classed("focusCircle",true).raise();
        $("#varselect").val(listnames);

        d3.select(".overlay1").style("pointer-events","none");

        d3.selectAll(".circles").classed("focusCircle",false);
        d3.selectAll("#" + listnames[0]).classed("focusCircle",true).raise();

        xpos = d3.selectAll("#" + listnames[0]).attr("cx");
        ypos = d3.selectAll("#" + listnames[0]).attr("cy");

        classString = d3.select("#" + listnames[0]).attr("class");

        splitString = classString.split(" ");

        indexString = splitString[3].split("index");

        myObj = {}

        myObj[0] = xpos;
        myObj[1] = ypos;

        xVal = x.invert(xpos);
        yVal =y.invert(ypos);
        myObj['data'] = [xVal,yVal];
        myObj['index'] = indexString[1]

        tip(myObj)
     }

    }//end checkUrl

checkUrl()
}//end drawGraphic




    //then, onload, check to see if the web browser can handle 'inline svg'
    if (Modernizr.svg)
    {
      // open and load configuration file.
      d3.json("data/config.json", function(error, json)
      {
        // store read in json data from config file as as global dvc. variable ...
        dvc = json;
        //load chart data
        d3.csv(dvc.essential.graphic_data_url, function(error, data) {
          // read in and store data held in CSV as global data variable.
          graphic_data = data;



          pymChild = new pym.Child({renderCallback: drawGraphic});
        })// end data load
      })// end of d3.json
    } // end modernizr if ...
    else {
      //use pym to create iframe containing fallback image (which is set as default)
      pymChild = new pym.Child();

      d3.select("#graphic").empty();
      d3.select("#graphic").append("img").attr("src","fallback.png");

      if (pymChild) { pymChild.sendHeight(); }
    }	// end else ...


  </script>
</html>
